import { Future, Option } from '..';
export declare class List<T> {
    private readonly items;
    private readonly length;
    constructor(items: T[]);
    append(item: T): List<T>;
    prepend(item: T): List<T>;
    map<U>(f: (item: T) => U): List<U>;
    parallelMap<U, E>(f: (item: T) => U): Future<U[], E>;
    sort(): List<T>;
    sortBy<U>(f: (item: T) => U): List<T>;
    sortDescendingly(): List<T>;
    sortDescendinglyBy<U>(f: (item: T) => U): List<T>;
    size(): number;
    isEmpty(): boolean;
    isNotEmpty(): boolean;
    all(predicate: (item: T) => boolean): boolean;
    some(predicate: (item: T) => boolean): boolean;
    none(predicate: (item: T) => boolean): boolean;
    count(predicate: (item: T) => boolean): number;
    contains(item: T): boolean;
    equals(otherList: List<T>): boolean;
    get(index: number): Option<T>;
    getOrElse(index: number, alternative: T | (() => T)): T;
    take(n: number): List<T>;
    filter(predicate: (item: T) => boolean): List<T>;
    first(predicate?: (item: T) => boolean): Option<T>;
    last(predicate?: (item: T) => boolean): Option<T>;
    concat(otherList: List<T>): List<T>;
    groupBy(computeKey: (item: T) => string): {
        [id: string]: T[];
    };
    perform(sideEffect: (list: List<T>) => void): void;
    performOnEmpty(sideEffect: (list: List<T>) => void): void;
    performOnNonEmpty(sideEffect: (list: List<T>) => void): void;
    forEach(sideEffects: (item: T) => void): void;
    toArray(): T[];
    flatten<U>(this: List<List<U> | U[]>): List<U>;
    chain(f: (T: any) => List<T>): List<T>;
}
export declare function list<T>(...array: T[]): List<T>;
export declare function emptyList<T>(): List<T>;
export declare function listFromArray<T>(array: T[]): List<T>;
