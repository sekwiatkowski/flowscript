import { Equivalence, Future, Monoid, NonEmptyList, Option, Order, Predicate, Semigroup } from '..';
export declare class List<T> {
    private readonly items;
    private readonly length;
    constructor(items: T[]);
    first(): Option<T>;
    get(index: number): Option<T>;
    getArray(): T[];
    getOrElse(index: number, alternative: T | (() => T)): T;
    last(): Option<T>;
    take(n: number): List<T>;
    flatten<U>(this: List<List<U> | U[]>): List<U>;
    chain(f: (T: any) => List<T>): List<T>;
    concat(other: T[] | List<T>): List<T>;
    combine(other: T[], semigroup: Semigroup<T[]>): any;
    combine(other: List<T>, semigroup: Semigroup<List<T>>): List<T>;
    append(item: T): NonEmptyList<T>;
    prepend(item: T): NonEmptyList<T>;
    groupBy(computeKey: (item: T) => string): {
        [id: string]: T[];
    };
    map<U>(f: (item: T) => U): List<U>;
    parallelMap<U, E>(f: (item: T) => U): Future<U[], E>;
    match<X>(onNonEmpty: (array: T[]) => X, onEmpty: () => X): X;
    reduceBy<U>(by: (item: T) => U, operation: (a: U) => (b: U) => U): Option<U>;
    reduce(operation: (a: T) => (b: T) => T): Option<T>;
    reduceByWithSemigroup<U>(by: (item: T) => U, semigroup: Semigroup<U>): Option<U>;
    reduceWithSemigroup(semigroup: Semigroup<T>): Option<T>;
    foldBy<U>(by: (item: T) => U, operation: (a: U) => (b: U) => U, initialValue: U): Option<U>;
    fold(operation: (a: T) => (b: T) => T, initialValue: T): Option<T>;
    foldByWithMonoid<U>(by: (item: T) => U, monoid: Monoid<U>): Option<U>;
    foldWithMonoid(monoid: Monoid<T>): Option<T>;
    earliest(this: List<Date>): Option<Date>;
    earliestBy<U>(this: List<T>, by: (item: T) => Date): Option<Date>;
    latest(this: List<Date>): Option<Date>;
    latestBy<U>(this: List<T>, by: (item: T) => Date): Option<Date>;
    max(this: List<number>): Option<number>;
    maxBy(by: (item: T) => number): Option<number>;
    min(this: List<number>): Option<number>;
    minBy(by: (item: T) => number): Option<number>;
    sum(this: List<number>): Option<number>;
    sumBy(by: (item: T) => number): Option<number>;
    product(this: List<number>): Option<number>;
    productBy(by: (item: T) => number): Option<number>;
    filter(predicate: ((item: T) => boolean) | Predicate<T>): List<T>;
    find(predicate: ((item: T) => boolean) | Predicate<T>): Option<T>;
    findLast(predicate: ((item: T) => boolean) | Predicate<T>): Option<T>;
    perform(sideEffect: (list: List<T>) => void): void;
    performOnEmpty(sideEffect: (list: List<T>) => void): void;
    performOnNonEmpty(sideEffect: (list: List<T>) => void): void;
    forEach(sideEffect: (item: T) => void): void;
    size(): number;
    isEmpty(): boolean;
    isNotEmpty(): boolean;
    sort(order?: Order<T>): List<T>;
    sortBy<U>(by: (item: T) => U): List<T>;
    sortDescendingly(): List<T>;
    sortDescendinglyBy<U>(by: (item: T) => U): List<T>;
    contains(item: T, itemEquality?: (((x: T, y: T) => boolean) | Equivalence<T>)): boolean;
    equals(otherList: List<T>): boolean;
    all(predicate: ((item: T) => boolean) | Predicate<T>): boolean;
    some(predicate: ((item: T) => boolean) | Predicate<T>): boolean;
    none(predicate: ((item: T) => boolean) | Predicate<T>): boolean;
    count(predicate: ((item: T) => boolean) | Predicate<T>): number;
    test(predicate: (items: T[]) => boolean): boolean;
    test(predicate: Predicate<T[]>): boolean;
}
export declare function emptyList<T>(): List<T>;
export declare function listFromArray<T>(array: T[]): List<T>;
export declare function range(start: number, end?: number): List<number>;
export declare function repeat<T>(times: number, valueOrFunction: T | ((index?: number) => T)): List<T>;
export declare const anyListEquality: Equivalence<List<any>>;
